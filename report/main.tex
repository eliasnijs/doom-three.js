\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{float}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{url} % Better URL handling
\urlstyle{same} % Use the same font for URLs
\usepackage{apacite}
\usepackage{enumitem} % For nested lists in maze generation section
\usepackage[margin=1.5in]{geometry} % Reduce horizontal padding
\usepackage{tikz} % For creating plots and diagrams
\usepackage{pgfplots} % For creating plots
\pgfplotsset{compat=1.18} % Set compatibility level

\title{Simple Doom Game Clone in Three.js}
\author{Elias Nijs \& René Van Der Schueren}
\date{May 2025}

% Custom title page information
\newcommand{\courseinfo}{Computer Graphics (E016712A)}
\newcommand{\academicyear}{Academic Year 2024/2025}
\newcommand{\university}{GHENT UNIVERSITY}

\begin{document}

% Custom title page
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    \Huge
    \textbf{Simple Doom Game Clone in Three.js}\\
    \vspace{1.5cm}
    
    \Large
    \textbf{\courseinfo}\\
    \vspace{0.5cm}
    
    \large
    \university\\
    \vspace{0.5cm}
    
    \vspace{1.5cm}
    
    \Large
    Elias Nijs \& René Van Der Schueren\\
    \vspace{0.5cm}
    
    \large
    \academicyear\\
    \vspace{0.5cm}
    
    \large
    May 2025\\
    
\end{titlepage}

\pagebreak

\tableofcontents

\pagebreak

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{diagrams/gameplay.png}
    \caption{Gameplay screenshot of our Doom-inspired game implemented in Three.js.}
    \label{fig:gameplay-main}
\end{figure}

\section{Introduction}\label{sec:introduction}
\subsection{Tech Choices}
Our project leverages Three.js, a lightweight, cross-browser JavaScript library that abstracts WebGL, making 3D graphics programming significantly more accessible. It provides a comprehensive set of features for creating and displaying animated 3D computer graphics in web browsers without requiring users to install additional plugins. Three.js was the best option for its robust ecosystem, extensive documentation, and optimized performance for web-based 3D rendering.

Our development workflow is built around Vite, a modern frontend build tool that provides an extremely fast development server through native ES modules.

We implemented the entire codebase in TypeScript rather than vanilla JavaScript to enhance our development process. TypeScript's static typing helps catch errors during development rather than at runtime, significantly improving code reliability. The explicit type definitions serve as built-in documentation, making it easier for team members to understand each other's code and collaborate effectively.

\subsection{Gameplay Overview}
Our game is a first-person shooter inspired by the classic Doom, implemented using Three.js. Players navigate through procedurally generated mazes, interact with doors, follow path markers, and encounter various props while trying to reach their destination. Players can also shoot their gun to open doors, adding a combat element to the navigation mechanics.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{diagrams/screenshot.png}
    \caption{Gameplay screenshot showing key elements: (A) Debug menu for adjusting game parameters, (B) Closed door with its control panel (C), (D) Path markers guiding the player through an open door, (E) Mini-map displaying player position and path to destination, (F) Barrel spawned as a random prop, and (G) Weapon in gun mode.}
    \label{fig:gameplay-overview}
\end{figure}

Figure \ref{fig:gameplay-overview} illustrates the main gameplay elements:
\begin{itemize}
    \item \textbf{A:} Debug menu that allows changing camera settings, enabling debug mode, and displays game engine statistics.
    \item \textbf{B:} A door that was previously opened, allowing passage through the maze.
    \item \textbf{C:} Door control panel that can be activated by shooting it with the player's weapon.
    \item \textbf{D:} Path markers showing the optimal route to the destination, guiding the player through an open door.
    \item \textbf{E:} Mini-map displaying the player's current position and the path to the destination.
    \item \textbf{F:} Barrel that was procedurally spawned as a random prop in the environment.
    \item \textbf{G:} The player's weapon in gun mode.
\end{itemize}


\section{Game Engine}
Before diving into specific features, we'll provide an overview of our custom game engine architecture that powers the entire application.

\subsection{Core Architecture}
Our game engine follows a component-based design pattern, with a central state management system that coordinates all game elements. The engine is structured around these key components:

\begin{itemize}
    \item \texttt{GameObject}: An abstract base class that serves as the foundation for all entities in the game world. Each game object automatically registers itself with the state management system upon creation and implements lifecycle methods such as \texttt{animate} (called every frame), \texttt{cleanup}, and \texttt{destroy}.
    
    \item \texttt{State}: The central management class that maintains references to all active game objects, handles scene configuration, manages the camera system, and coordinates the physics simulation. It provides methods for registering and unregistering game objects, finding objects by type, toggling debug visualization, ...
    
    \item \texttt{Physics}: A collision detection and resolution system that uses axis-aligned bounding boxes (AABBs) to represent object boundaries. The physics system calculates collision corrections and applies them to maintain proper object separation. For efficient collision detection, we implemented an octree-based spatial partitioning system (explained in detail in the Space Partitioning section), which significantly reduces the number of collision checks by organizing objects hierarchically based on their spatial location.
\end{itemize}

\subsection{Rendering Pipeline}
The rendering system leverages Three.js capabilities while adding custom functionality:

\begin{itemize}
    \item Scene with visual features such as ambient lighting, exponential fog for atmosphere, and HDR environment mapping for realistic reflections.
    
    \item A dual-camera system that allows switching between a first-person player view and a freely moveable camera.
    
    \item Debug visualization tools that can render collision boundaries and octree structure when enabled.
\end{itemize}

\subsection{Game Loop}
The engine implements a standard game loop that:

\begin{enumerate}
    \item Updates the physics system and rebuilds the dynamic octree.
    \item Calls the \texttt{animate} method on all registered game objects.
    \item Handles user input and camera updates.
    \item Renders the scene.
\end{enumerate}

This architecture provides a solid foundation for implementing the game-specific features described in the following sections.

\section{Maze Generation}
First, we will start by explaining our maze generation algorithm, which forms the foundation of our game's level design.

\subsection{Implementation}

The maze generation system is implemented as a modular component in the utils directory. It provides function for creating the abstract maze structure but not for converting it to the physical 3D environment. This separation of concerns allows the maze logic to be tested independently from the game rendering system while maintaining a clean integration between the two.

\subsubsection{Data Structures}
The maze is represented by a grid of cells, where each cell contains information about its walls and visited state:
\begin{itemize}
    \item \texttt{Cell}: A type representing a single cell in the maze with properties for walls (north, east, south, west) and a visited flag.
    \item \texttt{Grid}: A type containing an array of cells and dimensions (number of rows and columns).
    \item \texttt{Pos}: A type alias for a position in the grid, represented as [row, column].
\end{itemize}

\subsubsection{Generation Algorithm}
The maze generation follows these steps:
\begin{enumerate}
    \item Initialize a grid where all cells have all four walls intact and are marked as unvisited.
    \item Start at a cell (typically [0,0]) and mark it as visited.
    \item Push the starting cell onto a stack to track the path.
    \item While the stack is not empty:
    \begin{enumerate}
        \item Get the current cell from the top of the stack.
        \item If the current cell has any unvisited neighbors:
        \begin{enumerate}
            \item Choose one randomly.
            \item Remove the wall between the current cell and the chosen neighbor.
            \item Mark the neighbor as visited.
            \item Push the neighbor onto the stack.
        \end{enumerate}
        \item If there are no unvisited neighbors, pop the current cell from the stack (backtrack).
    \end{enumerate}
\end{enumerate}

This algorithm ensures that every cell in the maze is reachable from any other cell, creating a perfect maze with exactly one path between any two points.

\subsubsection{Upscaling}
The implementation includes an optional upscaling feature that doubles the effective resolution of the maze by inserting buffer cells between the original cells. This creates a more visually appealing maze with wider corridors while maintaining the logical structure of the original maze. Additionally, the upscaling process leaves room between parallel hallways, providing space for game elements such as doors to animate into when opened, enhancing the interactive experience without causing clipping or collision issues. Figure \ref{fig:maze-spacing} illustrates the difference between a maze without spacing and one with spacing, clearly showing how the upscaling creates buffer zones between parallel corridors.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{diagrams/spacing.png}
    \caption{Comparison of a 10x10 maze: left without spacing, right with spacing, viewed from the top in debug mode. Notice the extra spacing making sure that parallel hallways do not touch.}
    \label{fig:maze-spacing}
\end{figure}

\subsubsection{Pathfinding}
The implementation features an efficient A* pathfinding algorithm that calculates optimal routes between any two points in the maze. This algorithm employs a Manhattan distance heuristic—particularly suitable for grid-based movement—and accounts for walls when evaluating potential paths. The pathfinding system provides visual guidance for players through path markers that highlight the shortest route to objectives. The algorithm maintains separate data structures for tracking both the cost of the path so far (g-score) and the estimated total cost to the destination (f-score), ensuring optimal path discovery even in complex maze configurations.


\section{3D World Organization}
TODO

\section{User Controls and Movement}
TODO

\section{Lighting, Materials and Texture Mapping}
TODO

\section{Collision Detection Using Octree}
TODO

\subsection{Comparison with other space partitioning algorithms}

\section{Benchmarking}

\subsection{Maze Size Performance Analysis}
To evaluate the scalability of our implementation, we conducted performance tests with mazes of increasing size. All tests were performed on a MacBook Air (2022) with an Apple M2 chip, 8-core CPU, 8-core GPU, and 24GB of unified memory. The performance was measured in frames per second (FPS) while maintaining all graphical settings and game features at consistent levels.

Table \ref{tab:maze-performance} presents the relationship between maze dimensions, scene complexity (measured by the number of game objects and meshes), and rendering performance. The maze dimensions represent the logical grid size before upscaling, while the total tiles indicate the actual number of navigable cells in the generated maze.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Maze Size} & \textbf{Total Tiles} & \textbf{Game Objects} & \textbf{Mesh Count} & \textbf{FPS} \\ \hline
        10×10 & 100 & 204 & 697 & 100 \\ \hline
        20×20 & 400 & 904 & 2,844 & 100 \\ \hline
        40×40 & 1,600 & 3,204 & 11,595 & 50 \\ \hline
        80×80 & 6,400 & 12,804 & 46,477 & 10 \\ \hline
        160×160 & 25,600 & 51,204 & 187,113 & 2.5 \\ \hline
    \end{tabular}
    \caption{Performance metrics for different maze sizes showing the relationship between maze dimensions, scene complexity, and frame rate.}
    \label{tab:maze-performance}
\end{table}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
    \begin{axis}[
        width=0.8\textwidth,
        height=8cm,
        xlabel={Maze Size (Total Tiles)},
        ylabel={Frames Per Second (FPS)},
        xmode=log,
        ymode=log,
        log basis x=10,
        log basis y=10,
        grid=both,
        legend pos=north east,
        xmin=50, xmax=50000,
        ymin=1, ymax=200,
        xtick={100,1000,10000},
        xticklabels={$10^2$,$10^3$,$10^4$},
        ytick={1,10,100},
        yticklabels={1,10,100},
        title={Performance Scaling with Maze Size}
    ]
    
    % FPS vs Total Tiles data points
    \addplot[color=blue,mark=*,thick] coordinates {
        (100, 100)
        (400, 100)
        (1600, 50)
        (6400, 10)
        (25600, 2.5)
    };
    
    % Theoretical inverse relationship curve (1/x)
    \addplot[color=red,dashed,domain=100:25600,samples=100] {10000/x};
    
    \legend{Measured FPS, Theoretical $O(1/n)$ scaling}
    \end{axis}
    \end{tikzpicture}
    \caption{Log-log plot showing the relationship between maze size (total tiles) and performance (FPS). The dashed red line represents theoretical inverse scaling, demonstrating how our implementation closely follows expected performance characteristics as scene complexity increases.}
    \label{fig:performance-scaling}
\end{figure}

As evident from the data, our implementation maintains an optimal frame rate of 100 FPS for mazes up to 20×20 (400 tiles), demonstrating that the game is well-optimized for small to medium-sized environments. Note that the 100 FPS ceiling is due to the testing monitor's maximum refresh rate; the actual performance for smaller mazes may exceed this value. Performance begins to degrade at 40×40 (1,600 tiles), dropping to 50 FPS, which is still playable but shows the increasing computational demands.

At the extreme end, the 160×160 maze (containing 25,600 tiles and over 187,000 meshes) pushes the hardware to its limits, resulting in only 5 FPS. While not playable, this test demonstrates the upper bounds of our implementation on consumer hardware and provides valuable insights for future optimization efforts.

\subsection{Octree}

\pagebreak
\section{Art Credits}
While the focus of this project was on the technical implementation of computer graphics concepts, we utilized several third-party 3D models and textures to enhance the visual quality of our game. All assets were used under appropriate licenses, and modifications were made to better suit our game's aesthetic and technical requirements.

\begin{itemize}
    \item \textbf{Hallway Modules}: The modular hallway system was based on assets from "Spaceship Modules" by ThisIsBranden, available at \url{https://thisisbranden.itch.io/spaceship-modules}.
    
    \item \textbf{Environmental Props}: Various props such as barrels and crates were sourced from the "Sci-Fi Assets Pack" available on TurboSquid at \url{https://www.turbosquid.com/3d-models/sci-fi-assets-model-1876664}.
    
    \item \textbf{Weapon Model}: The player's gun was adapted from the "Sci-Fi DMR" model available on TurboSquid at\\\url{https://www.turbosquid.com/3d-models/3d-scifi-dmr-model-1983451}.
\end{itemize}

Small modifications were made to these models using Blender. Texture adjustments were performed using Krita. This was done to maintain a consistent visual style throughout the game environment.

% \pagebreak
% \nocite{*}
% \bibliographystyle{apacite}
% \bibliography{references}

\end{document}
